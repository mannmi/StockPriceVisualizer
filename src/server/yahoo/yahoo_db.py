import argparse
import logging
import os

from pandas import isna

from src.logging.logging_config import logger, set_log_level
import pandas as pd
from src.server.DatabaseManager.DatabaseManager import DatabaseManager
from src.config_loader.configLoader import YmlLoader
from src.server.yahoo.dataProcesingYahoo import DataProcessorYahoo
from src.os_calls.basic_os_calls import clear, is_running_in_docker

logger.info("MySQL Connector is installed and working!")


class Yahoo(DatabaseManager):
    def __init__(self, docker_config_arg, api_key, ticker_file_path_arg):
        super().__init__(docker_config_arg, api_key)
        self.tickerFilePath = ticker_file_path_arg

    def store_data(self, symbol, df):
        """
        Store data for the given symbol in the database
        Args:
            symbol: symbol the data is from
            df: df containing the data

        Returns:

        """
        # Process the data using the DataProcessor class

        symbol_id = self.update_symbol(symbol)[0]

        self.connect()

        # Print column names to verify 'Datetime' exists
        logger.info("Columns in DataFrame: %s", df.columns)

        # Ensure Datetime column is in datetime format
        if ('Datetime', '') in df.columns or ('Date', '') in df.columns:
            df[('Datetime', '')] = pd.to_datetime(df[('Datetime', '')], errors='coerce')
            #df = df.dropna(subset=[('Datetime', ''), ('Date', '')])

            # Determine the ticker symbol dynamically
            ticker_symbol = df.columns.get_level_values('Ticker')[1]

            for index, row in df.iterrows():
                if not isna(row[('Datetime', '')]):
                    datetime_value = row[('Datetime', '')].strftime('%Y-%m-%d %H:%M:%S')
                else:
                    #logger.info("got it :)")
                    datetime_value = row[('Date', '')].strftime('%Y-%m-%d %H:%M:%S')
                #if datetime_value != ticker_symbol:
                open_value = row[('Open', ticker_symbol)]
                high_value = row[('High', ticker_symbol)]
                low_value = row[('Low', ticker_symbol)]
                close_value = row[('Close', ticker_symbol)]
                volume_value = row[('Volume', ticker_symbol)]

                # Convert each value to a scalar
                open_value = open_value.item() if isinstance(open_value, pd.Series) else open_value
                high_value = high_value.item() if isinstance(high_value, pd.Series) else high_value
                low_value = low_value.item() if isinstance(low_value, pd.Series) else low_value
                close_value = close_value.item() if isinstance(close_value, pd.Series) else close_value
                volume_value = volume_value.item() if isinstance(volume_value, pd.Series) else volume_value

                # generated by ai (this was generarated by chatgbt to fix a issue i was having)
                nan_value = next((value for value in [open_value, high_value, low_value, close_value, volume_value] if
                                  pd.isna(value)), None)
                if nan_value is not None:
                    logger.warning(f"NaN value found for {symbol} at {nan_value}. Skipping this row.")
                    continue

                self.cursor.execute('''
                        SELECT COUNT(*) FROM prices WHERE symbol_id = %s AND timestamp = %s
                    ''', (symbol_id, datetime_value))
                count = self.cursor.fetchone()[0]

                if count == 0:
                    self.cursor.execute('''
                            INSERT INTO prices (symbol_id, timestamp, open, high, low, close, volume)
                            VALUES (%s, %s, %s, %s, %s, %s, %s)
                        ''', (
                        symbol_id, datetime_value, open_value, high_value, low_value, close_value, volume_value
                    ))

            self.conn.commit()
        else:
            logger.error("Error: 'Datetime' column not found in DataFrame")

        self.close()
        logger.info(f"Data for {symbol} has been stored in the database.")

    # Fetch and store data for multiple tickers
    def fetch_and_store_symbol(self, tickers, api_key):
        if tickers.empty:
            raise ValueError("The list of tickers is empty. Please provide at least one ticker symbol.")

        for index, ticker in tickers.iterrows():
            try:
                self.update_symbol(ticker)
            except Exception as e:
                logger.error(f"An error occurred for {ticker}: {e}")

    def fetch_and_store_data(self, tickers,api_key, fetch_recent=True ):
        try:
            watcher_list = self.get_ticker_list()
        except Exception as e:
            logger.error(f"An error occurred : {e}")
            return

        if tickers.empty:
            raise ValueError("The list of tickers is empty. Please provide at least one ticker symbol.")

        DataProcessorVar = DataProcessorYahoo(tickers, self.tickerFilePath)
        for index, ticker in watcher_list.iterrows():
            DataProcessorVar.ticker = ticker["symbol"]
            timestamp=0
            if(fetch_recent):
                timestamp = self.get_max_timestamp(ticker["symbol"])
                #exit()
            if(timestamp is not None):
                logger.info(f"Get Data in {ticker}")
                data_store = DataProcessorVar.process_data(timestamp)
                if data_store is not None:
                    logger.info(data_store.columns.tolist())
                    self.store_data(ticker, data_store)

    # def fetch_and_store_data(self, tickers, api_key):
    #     """
    #     Fetch Data from Yahoo and store the data in the database for the given tickers/smybol
    #     Args:
    #         tickers: symbol that will have the stock data fetched from Yahoo and stored in the database
    #         api_key: api key to fetch with (deprecated)
    #
    #     Returns:
    #
    #     """
    #     try:
    #         watcher_list = self.get_ticker_list()
    #     except Exception as e:
    #         logger.error(f"An error occurred : {e}")
    #         return
    #
    #     if tickers.empty:
    #         raise ValueError("The list of tickers is empty. Please provide at least one ticker symbol.")
    #
    #     data_processor_var = DataProcessorYahoo(tickers, self.tickerFilePath)
    #     for index, ticker in watcher_list.iterrows():
    #         data_processor_var.ticker = ticker["symbol"]
    #         data_store = data_processor_var.process_data()
    #         clear()
    #         # print(data_store.columns.tolist())
    #         print(data_store)
    #         self.store_data(ticker, data_store)


# Example usage
if __name__ == "__main__":

    parser = argparse.ArgumentParser(description="Database Setup Script.")

    # Define the --updatelist flag
    parser.add_argument('--updatelist', action='store_true', help="Update the list")
    # Define other flags
    parser.add_argument('--verbose', action='store_true', help="Enable verbose output")
    parser.add_argument('--config', type=str, help="Path to the configuration file")

    args = parser.parse_args()

    if args.updatelist:
        logger.info("Updating the list...")
    if args.verbose:
        set_log_level(logging.INFO)
    else:
        set_log_level(logging.DEBUG)
    if args.config:
        logger.info(f"Using configuration file: {args.config}")

    logger.info("starting the run")
    if is_running_in_docker():
        cpath_root = os.path.abspath("/app/")
    else:
        cpath_root = os.path.abspath("../../../")

    api_key_Load = 'your_api_key_here'  # Replace with your actual API key
    docker_config = cpath_root + '/docker-compose.yml'
    config_path = cpath_root + "/src/config_loader/config.yml"
    tickerFilePath = cpath_root + "/src/server/listing_status.csv"
    config = YmlLoader(docker_config)

    print("get tickets")
    dataProcessor = DataProcessorYahoo("A", tickerFilePath)

    print("Read All tickers")
    tickers_list = dataProcessor.read_all_tickers_from_file()

    print("Seting up db_manager")
    db_manager = (Yahoo(docker_config, config, tickerFilePath))
    db_manager.fetch_and_store_symbol(tickers_list, api_key_Load)

    print("Storing Data in Database")
    ticker_list = db_manager.get_ticker_list()
    # db_manager.fetch_and_store_data(tickers_list, api_key_Load)
    #
