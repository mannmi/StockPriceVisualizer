import os
import sys
import pandas as pd
from numpy.f2py.auxfuncs import throw_error

# config.yml
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '/app/')))
from src.logging.logging_config import logger
from src.server.DatabaseManager.DatabaseManager import DatabaseManager
from src.config_loader.configLoader import Yml_Loader
from src.server.yahoo.dataProcesingYahoo import DataProcessorYahoo
from src.os_calls.basic_os_calls import clear

logger.info("MySQL Connector is installed and working!")


class Yahoo(DatabaseManager):
    def __init__(self, docker_config, api_key, tickerFilePath):
        super().__init__(docker_config, api_key)
        self.tickerFilePath = tickerFilePath

    def store_data(self, symbol, df):
        # Process the data using the DataProcessor class

        symbol_id = self.update_symbol(symbol)[0]

        self.connect()

        # Print column names to verify 'Datetime' exists
        logger.info("Columns in DataFrame: %s", df.columns)

        # Ensure Datetime column is in datetime format
        if ('Datetime', '') in df.columns:
            df[('Datetime', '')] = pd.to_datetime(df[('Datetime', '')], errors='coerce')
            df = df.dropna(subset=[('Datetime', '')])  # Drop rows where conversion failed

            # Determine the ticker symbol dynamically
            ticker_symbol = df.columns.get_level_values('Ticker')[1]

            for index, row in df.iterrows():
                datetime_value = row[('Datetime', '')].strftime('%Y-%m-%d %H:%M:%S')
                open_value = row[('Open', ticker_symbol)]
                high_value = row[('High', ticker_symbol)]
                low_value = row[('Low', ticker_symbol)]
                close_value = row[('Close', ticker_symbol)]
                volume_value = row[('Volume', ticker_symbol)]

                # Convert each value to a scalar
                open_value = open_value.item() if isinstance(open_value, pd.Series) else open_value
                high_value = high_value.item() if isinstance(high_value, pd.Series) else high_value
                low_value = low_value.item() if isinstance(low_value, pd.Series) else low_value
                close_value = close_value.item() if isinstance(close_value, pd.Series) else close_value
                volume_value = volume_value.item() if isinstance(volume_value, pd.Series) else volume_value

                # generated by ai (this was generarated by chatgbt to fix a issue i was having)
                nan_value = next((value for value in [open_value, high_value, low_value, close_value, volume_value] if
                                  pd.isna(value)), None)
                if nan_value is not None:
                    logger.warning(f"NaN value found for {symbol} at {nan_value}. Skipping this row.")
                    continue

                self.cursor.execute('''
                        SELECT COUNT(*) FROM prices WHERE symbol_id = %s AND timestamp = %s
                    ''', (symbol_id, datetime_value))
                count = self.cursor.fetchone()[0]

                if count == 0:
                    self.cursor.execute('''
                            INSERT INTO prices (symbol_id, timestamp, open, high, low, close, volume)
                            VALUES (%s, %s, %s, %s, %s, %s, %s)
                        ''', (
                        symbol_id, datetime_value, open_value, high_value, low_value, close_value, volume_value
                    ))

            self.conn.commit()
        else:
            logger.error("Error: 'Datetime' column not found in DataFrame")

        self.close()
        logger.info(f"Data for {symbol} has been stored in the database.")

    # Fetch and store data for multiple tickers
    def fetch_and_store_symbol(self, tickers, api_key):
        configAuth = Yml_Loader('./config.yml')

        if tickers.empty:
            raise ValueError("The list of tickers is empty. Please provide at least one ticker symbol.")

        for index, ticker in tickers.iterrows():
            try:
                self.update_symbol(ticker)
            except Exception as e:
                logger.error(f"An error occurred for {ticker}: {e}")

    # def fetch_and_store_data(self, tickers,api_key, fetch_recent=True ):
    #     try:
    #         watcher_list = self.get_ticker_list()
    #     except Exception as e:
    #         logger.error(f"An error occurred : {e}")
    #         return
    #
    #     if tickers.empty:
    #         raise ValueError("The list of tickers is empty. Please provide at least one ticker symbol.")
    #
    #     DataProcessorVar = DataProcessorYahoo(tickers, self.tickerFilePath)
    #     for index, ticker in watcher_list.iterrows():
    #         DataProcessorVar.ticker = ticker["symbol"]
    #         timestamp=0
    #         if(fetch_recent):
    #             timestamp = self.get_max_timestamp(ticker["symbol"])
    #             #exit()
    #         if(timestamp is not None):
    #             logger.info(f"Get Data in {ticker}")
    #             data_store = DataProcessorVar.process_data()
    #             if data_store is not None:
    #                 logger.info(data_store.columns.tolist())
    #                 self.store_data(ticker, data_store)

    def fetch_and_store_data(self, tickers, api_key):
        try:
            watcher_list = self.get_ticker_list()
        except Exception as e:
            logger.error(f"An error occurred : {e}")
            return

        if tickers.empty:
            raise ValueError("The list of tickers is empty. Please provide at least one ticker symbol.")

        DataProcessorVar = DataProcessorYahoo(tickers, self.tickerFilePath)
        for index, ticker in watcher_list.iterrows():
            DataProcessorVar.ticker = ticker["symbol"]
            data_store = DataProcessorVar.process_data()
            clear()
            # print(data_store.columns.tolist())
            print(data_store)
            self.store_data(ticker, data_store)


# Example usage
if __name__ == "__main__":

    parser = argparse.ArgumentParser(description="Database Setup Script.")

    # Define the --updatelist flag
    parser.add_argument('--updatelist', action='store_true', help="Update the list")
    # Define other flags
    parser.add_argument('--verbose', action='store_true', help="Enable verbose output")
    parser.add_argument('--config', type=str, help="Path to the configuration file")

    args = parser.parse_args()

    if args.updatelist:
        logger.info("Updating the list...")
    if args.verbose:
        set_log_level(logging.INFO)
    else:
        set_log_level(logging.DEBUG)
    if args.config:
        logger.info(f"Using configuration file: {args.config}")

    logger.info("starting the run")

    api_key_Load = 'your_api_key_here'  # Replace with your actual API key
    docker_config = '/app/docker-compose.yml'
    config_path = "/app/config_loader/config.yml"
    tickerFilePath = "/app/server/listing_status.csv"
    config = Yml_Loader(docker_config)

    print("get tickets")
    dataProcessor = DataProcessorYahoo("A", tickerFilePath)

    print("Read All tickers")
    tickers_list = dataProcessor.read_all_tickers_from_file()

    print("Seting up db_manager")
    db_manager = (Yahoo(docker_config, config, tickerFilePath))
    db_manager.fetch_and_store_symbol(tickers_list, api_key_Load)

    print("Storing Data in Database")
    # tickers_list = db_manager.get_ticker_list()
    # db_manager.fetch_and_store_symbol(tickers_list, 0)
    ticker_list = db_manager.get_ticker_list()
    # print(ticker_list)
    # db_manager.fetch_and_store_data(tickers_list, api_key_Load)

